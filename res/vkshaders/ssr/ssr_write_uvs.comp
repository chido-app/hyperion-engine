#version 450

#include "ssr_header.inc"

layout(set = HYP_DESCRIPTOR_SET_GLOBAL, binding = 12, rgba16f) uniform writeonly image2D ssr_uvs;

float SSRAlpha(vec3 dir, vec3 origin, vec3 hitPosition)
{
	float alpha = 1.0;
	// fade based on direction relative to camera
    //float eyeDirection = clamp( dir.z, ssr_params.eye_fade_start, ssr_params.eye_fade_end);
    //alpha *= ((eyeDirection - ssr_params.eye_fade_start) / (ssr_params.eye_fade_end - ssr_params.eye_fade_start));

	// Fade ray hits based on distance from ray origin
	// float dist = distance(origin, hitPosition);
	// alpha *= 1.0 - clamp(dist / ssr_params.max_ray_distance, 0.0, 1.0);

	return alpha;
}

// returns uvs of ray hit
void TraceRays(vec3 position, vec3 reflection, out vec2 out_uv, out float out_mask)
{
	vec3 step = ssr_params.ray_step * reflection;
	vec3 marchingPosition = position + step;
	float delta;
	float depthFromScreen;
	vec2 screenPosition;
	
	int i = 0;
	bool do_binary_search = false;

	for (; i < ssr_params.num_iterations; i++) {
		screenPosition = generateProjectedPosition(marchingPosition);

		float depth = SampleGBuffer(gbuffer_depth_texture, screenPosition).x;

		depthFromScreen = generatePositionFromDepth(screenPosition, depth).z;
		delta = marchingPosition.z - depthFromScreen;

		if (delta > 0.0) {
			do_binary_search = true;

			break;
		}
		
		marchingPosition += step;
    }

	const int max_binary_search_steps = 10;

	if (do_binary_search) {
		// binary search
		for(i = 0; i < max_binary_search_steps; i++) {
			step *= 0.5;
			marchingPosition = marchingPosition - step * sign(delta);
			
			screenPosition = generateProjectedPosition(marchingPosition);
			depthFromScreen = abs(generatePositionFromDepth(screenPosition, SampleGBuffer(gbuffer_depth_texture, screenPosition).x).z);
			delta = abs(marchingPosition.z) - depthFromScreen;
			
			if (abs(delta) < ssr_params.distance_bias) {
				float alpha = SSRAlpha(reflection, position, marchingPosition);

				vec2 hitPixelNDC = screenPosition * 2.0 - 1.0;
				float maxDimension = min(1.0, max(abs(hitPixelNDC.x), abs(hitPixelNDC.y)));
				alpha *= 1.0 - max(0.0, maxDimension - ssr_params.screen_edge_fade_start) / (1.0 - ssr_params.screen_edge_fade_start);
				alpha = clamp(alpha, 0.0, 1.0);

				out_uv   = screenPosition;
				out_mask = alpha;

				return;
			}
		}
	}

	out_uv   = vec2(0.0);
	out_mask = 0.0;
}

void PerformSSR(ivec2 coord, out vec2 out_uv, out float out_mask)
{
	vec2 texcoord = vec2(coord) / vec2(ssr_params.dimension.x, ssr_params.dimension.y);

	float depth = SampleGBuffer(gbuffer_depth_texture, texcoord).r;
    vec4 position = vec4(generatePositionFromDepth(texcoord, depth), 1.0);
	vec4 normal = scene.view * vec4(DecodeNormal(SampleGBuffer(gbuffer_normals_texture, texcoord)), 0.0);
	vec3 V = normalize(scene.camera_position.xyz - position.xyz);
	vec3 N = normalize(normal.xyz);

	vec3 R = normalize(reflect(position.xyz, N));


	// if (dot(-normalize((scene.view * vec4(0.0, 0.0, 0.0, 1.0)).xyz), N) < 0.5) {//dot(normalize(reflect(-V, N)), N) < 0.001) {
	// 	out_uv = vec2(0.0);
	// 	out_mask = 0.0;
	// 	return;
	// }
	
	TraceRays(
		position.xyz,
		normalize(R + (N * ssr_params.offset)),
		out_uv,
		out_mask
	);
}

void main(void)
{
    ivec2 coord    = ivec2(gl_GlobalInvocationID.xy);
	vec2  texcoord = vec2(coord) / vec2(ssr_params.dimension.x, ssr_params.dimension.y);

	vec2  out_uv   = vec2(0.0);
	float out_mask = 0.0;

	PerformSSR(coord, out_uv, out_mask);

	//float roughness = SampleGBuffer(gbuffer_material_texture, texcoord).r;

    imageStore(ssr_uvs, coord, vec4(out_uv, 0.0, out_mask));
}
