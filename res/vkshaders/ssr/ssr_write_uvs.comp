#version 450

#include "ssr_header.inc"

layout(set = HYP_DESCRIPTOR_SET_GLOBAL, binding = 12, rgba16f) uniform writeonly image2D ssr_uvs;


#define SSR_MAX_ITERATIONS 80
#define SSR_MAX_BINARY_SEARCH_ITERATIONS 8
#define SSR_PIXEL_STRIDE 1
#define SSR_PIXEL_STRIDE_CUTOFF 1
#define SSR_MAX_RAY_DISTANCE 128
#define SSR_SCREEN_EDGE_FADE_START 0.9
#define SSR_EYE_FADE_START 0.8
#define SSR_EYE_FADE_END 0.995
#define SSR_Z_THICKNESS_THRESHOLD 0.1
#define SSR_JITTER_OFFSET 0.0

float linearDepth(float depth)
{
    //depth = depth * 0.5 + 0.5;
    //return scene.camera_near * scene.camera_far / (scene.camera_far + depth * (scene.camera_near - scene.camera_far));
    return scene.projection[3][2] / (depth * scene.projection[2][3] - scene.projection[2][2]);

}

float fetchDepth(vec2 uv)
{
    vec4 depthTexel = SampleGBuffer(gbuffer_depth_texture, uv);

    return depthTexel.r;// * 2.0 - 1.0;
}

bool rayIntersectDepth(float rayZNear, float rayZFar, vec2 hitPixel)
{
    // Swap if bigger
    if (rayZFar > rayZNear)
    {
        float t = rayZFar; rayZFar = rayZNear; rayZNear = t;
    }
    float cameraZ = linearDepth(fetchDepth(hitPixel));

    return rayZFar <= cameraZ && rayZNear >= cameraZ - SSR_Z_THICKNESS_THRESHOLD;
}

vec2 scene_resolution = vec2(ssr_params.dimension);

bool TraceRays(
    vec3 rayOrigin, vec3 rayDir, float jitter,
    out vec2 hitPixel, out vec3 hitPoint, out float iterationCount
)
{
    bool intersect = false;
    iterationCount = 0.0;

    vec3 step = ssr_params.ray_step * normalize(rayDir);
    vec3 marchingPosition = rayOrigin;
    float depthFromScreen;
    vec2 screenPosition;
    float step_delta;

    int i = 0;

	for (; i < ssr_params.num_iterations; i++) {
        marchingPosition += step;

        hitPixel = generateProjectedPosition(marchingPosition);

        float depth = SampleGBuffer(gbuffer_depth_texture, hitPixel).x;

        depthFromScreen = generatePositionFromDepth(hitPixel, depth).z;

        step_delta = marchingPosition.z - depthFromScreen;

        intersect = step_delta > 0.0;
        iterationCount += 1.0;

        if (intersect) {
            break;
        }
    }

    const int max_binary_search_steps = 8;

	if (intersect) {
		// binary search
		for (i = 0; i < max_binary_search_steps; i++) {
            step *= 0.5;
            marchingPosition = marchingPosition - step * sign(step_delta);

            hitPixel = generateProjectedPosition(marchingPosition);
            depthFromScreen = abs(generatePositionFromDepth(hitPixel, SampleGBuffer(gbuffer_depth_texture, hitPixel).x).z);
            step_delta = abs(marchingPosition.z) - depthFromScreen;

            if (abs(step_delta) < ssr_params.distance_bias) {
                return true;
            }
        }
    }

    return false;
}

float CalculateAlpha(
    float iterationCount, float reflectivity,
    vec2 hitPixel, vec3 hitPoint, float dist, vec3 rayDir
)
{
    float alpha = 1.0;
    // Fade ray hits that approach the maximum iterations
    alpha *= 1.0 - (iterationCount / float(SSR_MAX_ITERATIONS));
    // Fade ray hits that approach the screen edge
    vec2 hitPixelNDC = hitPixel * 2.0 - 1.0;
    float maxDimension = min(1.0, max(abs(hitPixelNDC.x), abs(hitPixelNDC.y)));
    alpha *= 1.0 - max(0.0, maxDimension - SSR_SCREEN_EDGE_FADE_START) / (1.0 - SSR_SCREEN_EDGE_FADE_START);

    // Fade ray hits base on how much they face the camera
    //float eyeDir = clamp(rayDir.z, SSR_EYE_FADE_START, SSR_EYE_FADE_END);
    //alpha *= 1.0 - (eyeDir - SSR_EYE_FADE_START) / (SSR_EYE_FADE_END - SSR_EYE_FADE_START);

    // Fade ray hits based on distance from ray origin
    alpha *= 1.0 - clamp(dist / ssr_params.max_ray_distance, 0.0, 1.0);

    return alpha;
}

void main(void)
{
    ivec2 coord    = ivec2(gl_GlobalInvocationID.xy);
	vec2  texcoord = vec2(coord) / vec2(ssr_params.dimension.x, ssr_params.dimension.y);

    float roughness = SampleGBuffer(gbuffer_material_texture, texcoord).r;
	vec3 N = DecodeNormal(SampleGBuffer(gbuffer_normals_texture, texcoord));
    vec3 viewSpaceN = normalize((scene.view * vec4(N, 0.0)).xyz);

    vec3 rayOrigin = generatePositionFromDepth(texcoord, fetchDepth(texcoord));
    vec3 rayDir = normalize(reflect(normalize(rayOrigin), viewSpaceN));


	vec2 hitPixel;
    vec3 hitPoint;
    float iterationCount;

    vec2 uv2 = texcoord * scene_resolution;
    float jitter = fract((texcoord.x + texcoord.y) * 0.25 + SSR_JITTER_OFFSET);

    bool intersect = TraceRays(rayOrigin, rayDir, jitter, hitPixel, hitPoint, iterationCount);

    float dist = distance(rayOrigin, hitPoint);

    float alpha = CalculateAlpha(iterationCount, 1.0 /* reflectivity */, hitPixel, hitPoint, dist, rayDir) * float(intersect);

    vec3 hitNormal = DecodeNormal(SampleGBuffer(gbuffer_normals_texture, hitPixel));
    hitNormal = normalize((scene.view * vec4(hitNormal, 0.0)).xyz);

    /*if (dot(hitNormal, rayDir) >= 0.0) {
        imageStore(ssr_uvs, coord, vec4(0.0));

        return;
    }*/

    if (!intersect) {
        imageStore(ssr_uvs, coord, vec4(0.0));

        return;
    }

    imageStore(ssr_uvs, coord, vec4(hitPixel, 0.0, alpha));
}