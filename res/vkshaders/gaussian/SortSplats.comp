#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout  : require
#extension GL_EXT_nonuniform_qualifier : require

#if !defined(MODE_SORT) && !defined(MODE_TRANSPOSE)
    #define MODE_SORT
#endif

#ifdef MODE_SORT
    #define BLOCK_SIZE 512

    layout(local_size_x = BLOCK_SIZE, local_size_y = 1, local_size_z = 1) in;
#elif defined(MODE_TRANSPOSE)
    #define BLOCK_SIZE 16

    layout(local_size_x = BLOCK_SIZE, local_size_y = BLOCK_SIZE, local_size_z = 1) in;
#endif


#include "../include/shared.inc"
#include "../include/defines.inc"

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS
#include "../include/scene.inc"
#include "../include/object.inc"
#include "../include/packing.inc"
#undef HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

#include "./Gaussian.glsl"

#define READ_INDEX(idx) \
    splat_indices[(idx) >> 2][(idx) & 3]

#define WRITE_INDEX(idx, value) \
    splat_indices[(idx) >> 2][(idx) & 3] = (value)

layout(std430, set = 0, binding = 3) buffer SplatIndicesBuffer
{
    uvec4 splat_indices[];
};

#define READ_DISTANCE(idx) \
    splat_distances[(idx) >> 2][(idx) & 3]

layout(std430, set = 0, binding = 4) readonly buffer SplatDistancesBuffer
{
    vec4 splat_distances[];
};

layout(std140, set = 0, binding = 5, row_major) readonly buffer SceneShaderData
{
    Scene scene;
};

layout(std140, set = 0, binding = 6, row_major) uniform CameraShaderData
{
    Camera camera;
};

layout(push_constant) uniform PushConstant {
    uint num_points;
    uint level;
    uint level_mask;
    uint width;
    uint height;
} push_constants;

#ifdef MODE_SORT

shared uint shared_data[BLOCK_SIZE];

#if 0
shared uint sharedData[512];

void BitonicSortStage(uint blockOffset, uint stride, bool direction) {
    uint globalIndex = gl_GlobalInvocationID.x;
    uint localIndex = gl_LocalInvocationID.x;
    
    uint indexA = blockOffset + (2 * stride * localIndex);
    uint indexB = indexA + stride;
    
    uint valueA = sharedData[indexA];
    uint valueB = sharedData[indexB];
    
    bool swap = (READ_DISTANCE(valueA) > READ_DISTANCE(valueB)) == direction;
    
    valueA = swap ? valueB : valueA;
    valueB = swap ? valueA : valueB;
    
    sharedData[indexA] = valueA;
    sharedData[indexB] = valueB;
}

void main() {
    uint globalIndex = gl_GlobalInvocationID.x;
    uint localIndex = gl_LocalInvocationID.x;
    
    uint blockStart = gl_WorkGroupID.x * 512;
    
    // Load data from global memory into shared memory
    sharedData[localIndex] = READ_INDEX(blockStart + localIndex);
    barrier();
    
    // Bitonic sort stages
    for (uint stride = 512; stride >= 2; stride /= 2) {
        for (uint subStride = stride / 2; subStride > 0; subStride /= 2) {
            uint direction = (localIndex / subStride) % 2;
            BitonicSortStage(localIndex, subStride, direction == 0);
            barrier();
        }
    }
    
    // Write sorted data back to global memory
    WRITE_INDEX(blockStart + localIndex, sharedData[localIndex]);
}

#else

void main()
{
    uint gi = gl_LocalInvocationIndex;

    if (gi >= push_constants.num_points) {
        return;
    }

    ivec2 dispatch_thread_id = ivec2(gl_GlobalInvocationID.xy);
    ivec2 local_invocation_id = ivec2(gl_LocalInvocationID.xy);

    // Load shared data
    shared_data[gi] = READ_INDEX(dispatch_thread_id.x);
    barrier();

    // Sort the shared data
    for (uint j = push_constants.level >> 1; j > 0; j >>= 1) {
        bool in_mask = bool(push_constants.level_mask & dispatch_thread_id.x);
        uint result = ((READ_DISTANCE(shared_data[gi & ~j]) > READ_DISTANCE(shared_data[gi | j])) == in_mask) ? shared_data[gi ^ j] : shared_data[gi];
        barrier();
        shared_data[gi] = result;
        barrier();
    }

    // Store shared data
    WRITE_INDEX(dispatch_thread_id.x, shared_data[gi]);
}

#endif

#elif defined(MODE_TRANSPOSE)

shared uint shared_data[BLOCK_SIZE * BLOCK_SIZE];

void main()
{
    ivec2 dispatch_thread_id = ivec2(gl_GlobalInvocationID.xy);
    ivec2 local_invocation_id = ivec2(gl_LocalInvocationID.xy);

    uint gi = gl_LocalInvocationIndex;

    if (gi >= push_constants.num_points) {
        return;
    }

    uint read_index = dispatch_thread_id.y * push_constants.width + dispatch_thread_id.x;

    shared_data[gi] = READ_INDEX(read_index);

	barrier();
	uvec2 xy = dispatch_thread_id.yx - local_invocation_id.yx + local_invocation_id.xy;

    uint write_index = xy.y * push_constants.height + xy.x;

	WRITE_INDEX(write_index, shared_data[local_invocation_id.x * BLOCK_SIZE + local_invocation_id.y]);
}

#endif