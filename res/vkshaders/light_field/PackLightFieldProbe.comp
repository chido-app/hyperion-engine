
#version 450

#extension GL_GOOGLE_include_directive : require

#include "./Shared.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "../include/defines.inc"
#include "../include/shared.inc"
#include "../include/brdf.inc"
#include "../include/noise.inc"
#include "../include/tonemap.inc"
#include "../include/packing.inc"

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS
#include "../include/env_probe.inc"

#include "../include/Octahedron.glsl"

layout(set = 0, binding = 0) uniform textureCube color_texture;
layout(set = 0, binding = 1) uniform textureCube normals_texture;
layout(set = 0, binding = 2) uniform textureCube depth_texture;

layout(set = 0, binding = 3) uniform sampler sampler_linear;
layout(set = 0, binding = 4) uniform sampler sampler_nearest;

layout(set = 0, binding = 5, rgba16f) uniform writeonly image2D color_image;
layout(set = 0, binding = 6, rg16f) uniform writeonly image2D normals_image;
layout(set = 0, binding = 7, rg16f) uniform writeonly image2D depth_image;

layout(push_constant) uniform PushConstant
{
    uvec4 probe_grid_position;
    uvec4 cubemap_dimensions;
    uvec2 probe_offset_coord;
};

vec3 MapXYSToDirection(uint face_index, vec2 uv) {
    vec3 dir = vec3(0.0);

    float u = uv.x;
    float v = -uv.y;

    // +x, -x, +y, -y, +z, -z
    switch (face_index) {
    case 0:
        dir = normalize(vec3(1.0, v, -u));
        break;
    case 1:
        dir = normalize(vec3(-1.0, v, u));
        break;
    case 2:
        dir = normalize(vec3(u, 1.0, -v));
        break;
    case 3:
        dir = normalize(vec3(u, -1.0, v));
        break;
    case 4:
        dir = normalize(vec3(u, v, 1.0));
        break;
    case 5:
        dir = normalize(vec3(-u, v, -1.0));
        break;
    }

    return dir;
}

vec2 NormalizeOctahedralCoord(uvec2 coord)
{
    ivec2 oct_frag_coord = ivec2((int(coord.x) - 2) % PROBE_SIDE_LENGTH_BORDER, (int(coord.y) - 2) % PROBE_SIDE_LENGTH_BORDER);
    
    return (vec2(oct_frag_coord) + vec2(0.5)) * (2.0 / float(PROBE_SIDE_LENGTH)) - vec2(1.0);
}

#define SAMPLE_COUNT 16

void main(void)
{
    const uvec2 coord = probe_offset_coord + uvec2(gl_GlobalInvocationID.xy) + 2;

    vec4 ibl = vec4(0.0);

    const float roughness = 0.6;
    const float perceptual_roughness = sqrt(roughness);
    const float lod = float(8.0) * perceptual_roughness * (2.0 - perceptual_roughness);

    
    const vec3 dir = DecodeOctahedralCoord(NormalizeOctahedralCoord(coord));

    
    const vec2 normals_sample = TextureCube(sampler_nearest, normals_texture, dir).rg;
    vec4 sample_ibl = TextureCube(sampler_linear, color_texture, dir);

    /*const vec3 N = normalize(DecodeNormal(vec4(normals_sample, 0.0, 0.0)));

    vec3 tangent;
    vec3 bitangent;
    ComputeOrthonormalBasis(N, tangent, bitangent);

    const vec3 V = -dir;

    for (int i = 0; i < SAMPLE_COUNT; i++) {
        vec2 rnd = Hammersley(uint(i), uint(SAMPLE_COUNT));

        vec3 H = ImportanceSampleGGX(rnd, N, roughness);
        H = tangent * H.x + bitangent * H.y + N * H.z;

        vec3 dir = normalize(2.0 * dot(V, H) * H - V);

        vec4 sample_ibl = TextureCube(sampler_linear, color_texture, dir);
        ibl += sample_ibl * (1.0 / float(SAMPLE_COUNT));
    }*/

    const vec2 depth_sample = TextureCube(sampler_nearest, depth_texture, dir).rg;

    // const float depth_sample_squared = depth_sample * depth_sample;

    imageStore(
        color_image,
        ivec2(coord),
        sample_ibl
    );

    imageStore(
        normals_image,
        ivec2(coord),
        vec4(normals_sample, 0.0, 0.0)
    );

    imageStore(
        depth_image,
        ivec2(coord),
        vec4(depth_sample, 0.0, 0.0)
    );


    
}
