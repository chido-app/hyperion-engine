#version 450

#extension GL_EXT_scalar_block_layout  : require
#extension GL_EXT_nonuniform_qualifier : require

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

#include "include/defines.inc"
#include "include/shared.inc"

layout(set = 0, binding = 0) uniform texture2D               mip_in;
layout(set = 0, binding = 1, r32f) uniform writeonly image2D mip_out;
layout(set = 0, binding = 2) uniform sampler                 depth_pyramid_sampler;

#define HYP_DEPTH_PYRAMID_SAMPLE_MAX
// #define HYP_DEPTH_PYRAMID_SAMPLE_MIN

#ifdef HYP_DEPTH_PYRAMID_SAMPLE_MAX
    #define HYP_DEPTH_CMP max    
#else
    #define HYP_DEPTH_CMP min
#endif

layout(push_constant) uniform DepthPyramidData {
    uvec2 mip_dimensions;
    uvec2 prev_mip_dimensions;
    uint  mip_level;
};

float GetDepthAtTexel(ivec2 coord, ivec2 offset)
{
//     if (coord.x + offset.x >= prev_mip_dimensions.x || coord.y + offset.y >= prev_mip_dimensions.y) {
// #ifdef HYP_DEPTH_PYRAMID_SAMPLE_MAX
//         return 0.0;
// #else
//         return 1.0;
// #endif
//     }

    vec2 inv_dimension = vec2(1.0) / vec2(prev_mip_dimensions);

    return Texture2D(depth_pyramid_sampler, mip_in, vec2(coord) * inv_dimension + (vec2(offset) * 0.5 * inv_dimension)).r;
}

const ivec2 offsets[8] = {
    ivec2(1, 0),
    ivec2(0, 1),
    ivec2(1, 1),
    ivec2(-1, 0),
    ivec2(0, -1),
    ivec2(-1, -1),
    ivec2(-1, 1),
    ivec2(1, -1)
};

void main()
{
    uvec2 coord    = gl_GlobalInvocationID.xy;
    vec2  texcoord = vec2(coord) / vec2(mip_dimensions);

    // sample 4 nearest neighbours and get MIN result... workaround for lack of min/max support on moltenvk
    ivec2 texel_coord = ivec2(texcoord * vec2(prev_mip_dimensions));

    float depth = GetDepthAtTexel(texel_coord, ivec2(0, 0));

    for (int i = 0; i < 8; i++) {
        depth = HYP_DEPTH_CMP(depth, GetDepthAtTexel(texel_coord, offsets[i]));
    }

    imageStore(mip_out, ivec2(coord), vec4(depth));
}

#undef HYP_DEPTH_CMP
