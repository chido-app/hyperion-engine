#version 450

#extension GL_EXT_scalar_block_layout  : require
#extension GL_EXT_nonuniform_qualifier : require

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

#include "include/defines.inc"
#include "include/shared.inc"

layout(set = 0, binding = 0) uniform texture2D               mip_in;
layout(set = 0, binding = 1, r32f) uniform writeonly image2D mip_out;
layout(set = 0, binding = 2) uniform sampler                 depth_pyramid_sampler;

#define HYP_DEPTH_PYRAMID_SAMPLE_MAX
// #define HYP_DEPTH_PYRAMID_SAMPLE_MIN

#ifdef HYP_DEPTH_PYRAMID_SAMPLE_MAX
    #define HYP_DEPTH_CMP max    
#else
    #define HYP_DEPTH_CMP min
#endif

layout(push_constant) uniform DepthPyramidData {
    uvec2 mip_dimensions;
    uvec2 prev_mip_dimensions;
    uint  mip_level;
};

float GetDepthAtTexel(ivec2 coord, ivec2 offset)
{
    ivec2 texel_coord = clamp(coord + offset, ivec2(0), ivec2(prev_mip_dimensions) - ivec2(1));

    return Texture2DTexel(depth_pyramid_sampler, mip_in, texel_coord).r;
}

const ivec2 offsets[4] = {
    ivec2(0, 0),
    ivec2(0, 1),
    ivec2(1, 1),
    ivec2(1, 0)
};

void main()
{
    uvec2 coord    = gl_GlobalInvocationID.xy;
    vec2  texcoord = vec2(coord) / vec2(mip_dimensions);

    ivec2 texel_coord = ivec2(texcoord * vec2(prev_mip_dimensions));

    float depth = 0.0;

    for (int i = 0; i < 4; i++) {
        depth = HYP_DEPTH_CMP(depth, GetDepthAtTexel(texel_coord, offsets[i]));
    }

    imageStore(mip_out, ivec2(coord), vec4(depth));
}

#undef HYP_DEPTH_CMP
