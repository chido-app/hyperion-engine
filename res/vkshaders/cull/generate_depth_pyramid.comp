#version 450

#extension GL_EXT_scalar_block_layout  : require
#extension GL_EXT_nonuniform_qualifier : require

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

#include "../include/defines.inc"
#include "../include/shared.inc"
#include "./shared.inc"

layout(set = 0, binding = 0) uniform texture2D               mip_in;
layout(set = 0, binding = 1, r32f) uniform writeonly image2D mip_out;
layout(set = 0, binding = 2) uniform sampler                 depth_pyramid_sampler;

layout(push_constant) uniform DepthPyramidData {
    uvec2 mip_dimensions;
    uvec2 prev_mip_dimensions;
    uint  mip_level;
};

float GetDepthAtTexel(vec2 texcoord, ivec2 offset)
{
    //const ivec2 texel_coord = clamp(ivec2((texcoord * vec2(prev_mip_dimensions - uvec2(1))) + vec2(offset) + vec2(0.5)), ivec2(0), ivec2(prev_mip_dimensions) - ivec2(1));
    // const ivec2 texel_coord = clamp(ivec2((texcoord * vec2(prev_mip_dimensions)) + vec2(offset)), ivec2(0), ivec2(prev_mip_dimensions) - ivec2(1));

    //return Texture2DTexelLod(depth_pyramid_sampler, mip_in, texel_coord, 0).r;

    const vec2 coord = texcoord + (vec2(offset) * (vec2(1.0) / vec2(prev_mip_dimensions)));

    return Texture2DLod(depth_pyramid_sampler, mip_in, coord, 0.0).r;
}

void main()
{
    const uvec2 coord = gl_GlobalInvocationID.xy;
    // ivec2 texel_coord = ivec2(texcoord * vec2(prev_mip_dimensions));

#if HYP_FEATURES_MINMAX_SAMPLER
    vec2  texcoord = (vec2(coord) + vec2(0.5)) / vec2(mip_dimensions);

    float depth = Texture2DLod(depth_pyramid_sampler, mip_in, texcoord, 0.0).r;
#else
    vec2  texcoord = vec2(coord) / vec2(mip_dimensions);

    float depth = 0.0;

    for (int i = 0; i < HYP_NUM_DEPTH_PYRAMID_OFFSETS; i++) {
        depth = HYP_DEPTH_CMP(depth, GetDepthAtTexel(texcoord, depth_pyramid_offsets[i]));
    }
#endif

    imageStore(mip_out, ivec2(coord), vec4(depth));
}

#undef HYP_DEPTH_CMP
