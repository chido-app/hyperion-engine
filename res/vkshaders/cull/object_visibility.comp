#version 450

#extension GL_EXT_scalar_block_layout  : require
#extension GL_EXT_nonuniform_qualifier : require

layout(local_size_x = 256) in;

#include "../include/defines.inc"
#include "../include/shared.inc"
#include "../include/aabb.inc"

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS
#include "../include/object.inc"
#include "../include/scene.inc"
#undef HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

// layout(std140, set = 0, binding = 0) readonly buffer ObjectBuffer {
//     Object objects[];
// };

layout(std430, set = 0, binding = 0, row_major) readonly buffer ObjectBuffer {
    Object objects[];
};

layout(std430, set = 0, binding = 1, row_major) readonly buffer SceneBuffer {
    Scene scenes[];
};

struct IndirectDrawCommand {
    // VkDrawIndexedIndirectCommand
    uint index_count;
    uint instance_count;
    uint first_index;
    int  vertex_offset;
    uint first_instance;
};

struct ObjectInstance {
    uint entity_id;
    uint draw_command_index;
    uint batch_index;
    uint num_indices;
};

layout(std140, set = 0, binding = 3) readonly buffer InstancesBuffer {
    ObjectInstance instances[];
};

layout(set = 0, binding = 4) writeonly buffer IndirectDrawCommandsBuffer {
    IndirectDrawCommand indirect_draw_commands[];
};

layout(set = 0, binding = 5) uniform texture2D depth_pyramid;
layout(set = 0, binding = 6) uniform sampler   depth_pyramid_sampler;

layout(push_constant) uniform ObjectVisibilityData {
    uint batch_offset;
    uint num_drawables;
    uint scene_id;
} push_constants;

void main()
{
    const uint id    = gl_GlobalInvocationID.x;
    const uint index = push_constants.batch_offset + id;

    if (id >= push_constants.num_drawables) {
        return;
    }

    ObjectInstance object_instance = instances[index];
    const uint entity_id           = object_instance.entity_id;
    const uint draw_command_index  = object_instance.draw_command_index;

    uint num_instances = 0;

    // entity id should not ever be zero/unset
    if (all(bvec2(entity_id, push_constants.scene_id))) {
        Object object = objects[entity_id - 1];
        Scene scene   = scenes[push_constants.scene_id - 1];

        AABB aabb;
        aabb.max = object.world_aabb_max.xyz;
        aabb.min = object.world_aabb_min.xyz;

        vec3  sphere_center;
        float sphere_radius;
        AABBToSphere(aabb, sphere_center, sphere_radius);

        // get view/proj matrices from scene.
        mat4 view = scene.view;
        mat4 proj = scene.projection;

        // convert worldspace aabb into screenspace aabb.

        // get optimal mip level of depth pyramid

        // compare depths from sampled depth pyramid.
        // if 

        ++num_instances;
    }

    indirect_draw_commands[draw_command_index].index_count    = object_instance.num_indices;
    indirect_draw_commands[draw_command_index].instance_count = num_instances;
    indirect_draw_commands[draw_command_index].first_index    = 0;
    indirect_draw_commands[draw_command_index].vertex_offset  = 0;
    indirect_draw_commands[draw_command_index].first_instance = 0;
}