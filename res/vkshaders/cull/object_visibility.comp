#version 450

#extension GL_EXT_scalar_block_layout  : require
#extension GL_EXT_nonuniform_qualifier : require

layout(local_size_x = 256) in;

#include "../include/defines.inc"
#include "../include/shared.inc"
#include "../include/aabb.inc"

#define HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS
#include "../include/object.inc"
#include "../include/scene.inc"
#undef HYP_DO_NOT_DEFINE_DESCRIPTOR_SETS

// layout(std140, set = 0, binding = 0) readonly buffer ObjectBuffer {
//     Object objects[];
// };

layout(std430, set = 0, binding = 0, row_major) readonly buffer ObjectBuffer {
    Object object;
} objects[];

layout(std140, set = 0, binding = 1, row_major) readonly buffer SceneBuffer {
    Scene scene;
};

struct IndirectDrawCommand {
    // VkDrawIndexedIndirectCommand
    uint index_count;
    uint instance_count;
    uint first_index;
    int  vertex_offset;
    uint first_instance;
};

struct ObjectInstance {
    uint entity_id;
    uint draw_command_index;
    uint batch_index;
    uint num_indices;
    vec4 bounding_sphere;
    vec4 aabb_max;
    vec4 aabb_min;
};

layout(std140, set = 0, binding = 3) readonly buffer InstancesBuffer {
    ObjectInstance instances[];
};

layout(set = 0, binding = 4) writeonly buffer IndirectDrawCommandsBuffer {
    IndirectDrawCommand indirect_draw_commands[];
};

layout(set = 0, binding = 5) uniform texture2D depth_pyramid;
layout(set = 0, binding = 6) uniform sampler   depth_pyramid_sampler;

layout(push_constant) uniform ObjectVisibilityData {
    uint  batch_offset;
    uint  num_drawables;
    uint  scene_id;
    uvec2 depth_pyramid_dimensions;
} push_constants;

// 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013
bool ProjectSphereToScreenSpaceAABB(vec3 C, float r, float znear, float P00, float P11, out vec4 aabb)
{
    if (C.z < r + znear)
        return false;

    vec2 cx = -C.xz;
    vec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r);
    vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
    vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

    vec2 cy = -C.yz;
    vec2 vy = vec2(sqrt(dot(cy, cy) - r * r), r);
    vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;
    vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;

    aabb = vec4(minx.x / minx.y * P00, miny.x / miny.y * P11, maxx.x / maxx.y * P00, maxy.x / maxy.y * P11);
    aabb = aabb.xwzy * vec4(0.5f, -0.5f, 0.5f, -0.5f) + vec4(0.5f); // clip space -> uv space

    return true;
}


void main()
{
    const uint id    = gl_GlobalInvocationID.x;
    const uint index = push_constants.batch_offset + id;

    if (id >= push_constants.num_drawables) {
        return;
    }

    ObjectInstance object_instance = instances[index];
    const uint entity_id           = object_instance.entity_id;
    const uint draw_command_index  = object_instance.draw_command_index;

    uint num_instances = 0;

    // entity id should not ever be zero/unset
    if (all(bvec2(entity_id, push_constants.scene_id))) {
        // Object object = objects[entity_id - 1].object;
        // Scene scene   = scenes[push_constants.scene_id - 1];

        // get view/proj matrices from scene.
        mat4 view = scene.view;
        mat4 proj = scene.projection;

        AABB aabb;
        aabb.max = object_instance.aabb_max.xyz;
        aabb.min = object_instance.aabb_min.xyz;

        const vec3 aabb_center = AABBGetCenter(aabb);

        const vec3 aabb_extent = AABBGetExtent(aabb);
        const vec3 aabb_corners[] = {
            aabb.min,
            aabb.min + vec3(aabb_extent.x, 0, 0),
            aabb.min + vec3(0, aabb_extent.y, 0),
            aabb.min + vec3(0, 0, aabb_extent.z),
            aabb.min + vec3(aabb_extent.xy, 0),
            aabb.min + vec3(0, aabb_extent.yz),
            aabb.min + vec3(aabb_extent.x, 0, aabb_extent.z),
            aabb.min + aabb_extent
        };

        float min_z = 1.0;
        vec2 min_xy = vec2(1.0);
        vec2 max_xy = vec2(0.0);

        // transform worldspace aabb to screenspace
        for (int i = 0; i < 8; i++) {
            vec4 clip_pos = proj * view * vec4(aabb_corners[i], 1.0);
            clip_pos.z = max(clip_pos.z, 0.0);
            clip_pos.xyz /= clip_pos.w;
            clip_pos.xy = clamp(clip_pos.xy, -1.0, 1.0);
            clip_pos.xy = clip_pos.xy * vec2(0.5, -0.5) + vec2(0.5);
            // clip_pos.y *= -1.0;

            min_xy = min(clip_pos.xy, min_xy);
            max_xy = max(clip_pos.xy, max_xy);
 
            min_z = clamp(min(min_z, clip_pos.z), 0.0, 1.0);
        }


        vec4 screenspace_aabb = vec4(min_xy, max_xy);
        // float width  = (screenspace_aabb.z - screenspace_aabb.x) * float(push_constants.depth_pyramid_dimensions.x);
        // float height = (screenspace_aabb.w - screenspace_aabb.y) * float(push_constants.depth_pyramid_dimensions.y);
        // float mip = floor(log2(max(width, height)));

        // Calculate hi-Z buffer mip
        uvec2 size = uvec2((max_xy - min_xy) * push_constants.depth_pyramid_dimensions);
        float mip = ceil(log2(max(size.x, size.y)));
 
        //mip = clamp(mip, 0, 12.0);
 
        // Texel footprint for the lower (finer-grained) level
        float level_lower = max(mip - 1, 0);
        float scale = exp2(-level_lower);
        vec2 a = floor(screenspace_aabb.xy * scale);
        vec2 b = ceil(screenspace_aabb.zw * scale);
        vec2 dims = b - a;
 
        // Use the lower level if we only touch <= 2 texels in both dimensions
        if (dims.x <= 2 && dims.y <= 2) {
            mip = level_lower;
        }

        //load depths from high z buffer
        const vec4 depths = {
            Texture2DLod(depth_pyramid_sampler, depth_pyramid, screenspace_aabb.xy, mip).r,
            Texture2DLod(depth_pyramid_sampler, depth_pyramid, screenspace_aabb.zy, mip).r,
            Texture2DLod(depth_pyramid_sampler, depth_pyramid, screenspace_aabb.xw, mip).r,
            Texture2DLod(depth_pyramid_sampler, depth_pyramid, screenspace_aabb.zw, mip).r
        };

        // const float depth_value = Texture2DLod(depth_pyramid_sampler, depth_pyramid, vec2(0.0), 0.0).r;
 
        // //find the max depth
        const float max_depth = max(max(max(depths.x, depths.y), depths.z), depths.w);

        // const float dist = distance(aabb_center, scene.camera_position.xyz);
        num_instances += 1;//int(min_z <= 0.98);//max_depth);

        /*vec3 sphere_center  = object_instance.bounding_sphere.xyz;
        float sphere_radius = object_instance.bounding_sphere.w;

        sphere_center = (view * vec4(sphere_center, 1.0)).xyz;
        sphere_center.y *= -1.0;

        vec4 screenspace_aabb;
        if (ProjectSphereToScreenSpaceAABB(
            sphere_center,
            sphere_radius,
            scene.camera_near,
            proj[0][0],
            proj[1][1],
            screenspace_aabb
        )) {
            float width  = (screenspace_aabb.z - screenspace_aabb.x) * float(push_constants.depth_pyramid_dimensions.x);
            float height = (screenspace_aabb.w - screenspace_aabb.y) * float(push_constants.depth_pyramid_dimensions.y);

            float level  = floor(log2(max(width, height)));

            float depth = Texture2DLod(
                depth_pyramid_sampler,
                depth_pyramid,
                vec2(screenspace_aabb.xy + screenspace_aabb.zw) * 0.5,
                level
            ).r;

            const vec4 depths = {
                Texture2DLod(depth_pyramid_sampler, depth_pyramid, screenspace_aabb.xy, level).r,
                Texture2DLod(depth_pyramid_sampler, depth_pyramid, screenspace_aabb.zy, level).r,
                Texture2DLod(depth_pyramid_sampler, depth_pyramid, screenspace_aabb.xw, level).r,
                Texture2DLod(depth_pyramid_sampler, depth_pyramid, screenspace_aabb.zw, level).r
            };

            //find the max depth
            const float max_depth = min(min(min(depths.x, depths.y), depths.z), depths.w);

            float depth_sphere = scene.camera_near / (sphere_center.z - sphere_radius);

            num_instances += int(depth_sphere > 0.05);//int(depth_sphere >= max_depth);*/
            // num_instances++;
        // } else {
        //     num_instances++;
        // }

        // convert worldspace aabb into screenspace aabb.

        // get optimal mip level of depth pyramid

        // compare depths from sampled depth pyramid.
        // if 

    }

    indirect_draw_commands[draw_command_index].index_count    = object_instance.num_indices;
    indirect_draw_commands[draw_command_index].instance_count = num_instances;
    indirect_draw_commands[draw_command_index].first_index    = 0;
    indirect_draw_commands[draw_command_index].vertex_offset  = 0;
    indirect_draw_commands[draw_command_index].first_instance = 0;
}