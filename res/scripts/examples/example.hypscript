module types {

    enum MyEnum {
        FOO,
        BAR = 0x04,
        TEST
    }

    let ui : uint = 0;

    print "ui + 5 = ", (ui + 5)

    print "MyEnum.FOO = ", MyEnum.FOO;
    print "MyEnum.BAR = ", MyEnum.BAR;
    print "MyEnum.TEST = ", MyEnum.TEST;

    function TakesEnum(e: int/*MyEnum*/)
    {
        print "e = ", e
    }

    TakesEnum(MyEnum.FOO);

    // custom types
    class UserClass {
        username: string
        password: string

        function printUsername(self) : int {
            print "hello, my name is: ", self.username

            return 5;
        }
    }

    class UserClass2<T> {
        username: T
        password: int

        function PrintName(self, id: T) {
            print "name = ", self.username;
            print "id = ", id;
        }
    }

    function DoThing<T>(thing: T): T
    {
        print "got type: ", thing, typeof(T);
    }

    let FooBar<T> = class {};

    let MyGeneric<T> = class {
        thing: T
        DoThing3 = function (self, t: T) {
            return t;
        }

        // DoThing4<U> = function (self, u: U) {
        //     return u;
        // }
    };

    class MyNonGeneric {
        thing: string
    }

    let user: UserClass2<int> = new UserClass2<int>
    user.username = 5432;
    let user1 = new UserClass
    let user2 = new UserClass
    let user3 = new UserClass
    let user4 = new UserClass
    let user5 = new UserClass
    print 'user = ', user
    print 'user1 = ', user1
    print 'user2 = ', user2
    print 'user3 = ', user3
    print 'user4 = ', user4
    print 'user5 = ', user5
    user.PrintName(1);

    DoThing<int>(4);

    // for item in [1,2,3,4] {
    //     print item
    // }


    let GenVar<T> = T;
    let f: float = 2.0;

    print "GenVar<Int> = ", GenVar<int>, " ", typeof(GenVar<int>);
    print "GenVar<Float> = ", GenVar<float>, " ", typeof(GenVar<float>);
    print "GenVar<String> = ", GenVar<string>, " ", typeof(GenVar<string>);
    print "f = ", f, typeof(f);

    print "DoThing2 = ", typeof(DoThing<float>);
    print "DoThing3 = ", typeof((new MyGeneric<float>).DoThing3);
    //print "DoThing4 = ", typeof((new MyGeneric<Float>).DoThing4<Int>);
    print "userclass = ", typeof(user.PrintName);
    print "userclass = ", typeof(user1.printUsername);

    // create an instance of the type
    //user := new User

    // array of User objects
    let users: UserClass2<int>[]// NOTE: same as writing Array<User>
    print "USERS = ", users

    let my_non_g: MyNonGeneric = new MyNonGeneric;
    print "my_non_g = ", my_non_g;
    print "my_non_g.thing = ", my_non_g.thing;

    let myg : MyGeneric<int> = new MyGeneric<int>;
    print typeof(myg)
    myg.thing = 1239;
    print "myg = ", myg;
    print "myg.thing = ", myg.thing;
    

    //print "users[0]", users[0]


    // NOTE: a User object cannot be null by default
    // to allow null, use Maybe<User> or User? (they're the same, but different syntax)

    //maybeUser: User? // NOTE: set to null by default.
    //maybeUser = new User // no longer null.
}
