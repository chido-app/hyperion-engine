


import mandelbrot;

// export class MovementController {
// public:
//     node: any;

//     MovementController(self: MovementController) : MovementController
//     {
//         self.node = null;

//         return self;
//     }

//     func OnAdded(self: MovementController, node: any)
//     {
//         self.node = node;

//         Print("Added controller to node: %s\n", node);
//     }

//     func OnRemoved(self: MovementController, node: any)
//     {
//         Print("Removed from node: %s\n", node);

//         self.node = null;
//     }

//     func OnTick(self: MovementController, node: any, delta: Float)
//     {

//     }
// };

// const movement_controller = new MovementController();

// export const OnAdded = movement_controller.OnAdded;
// export const OnRemoved = movement_controller.OnRemoved;
// export const OnTick = movement_controller.OnTick;



let controller_node: any = null;

let global_time: Float = 0.0;
let num_ticks: UInt = 0;

let test_vector = new Vector3();

func Expect( cond : Bool )
{
    Print("check cond: %\n", cond);

    if (!cond) {
        throw "Assertion failed!";
    }
}

class ClassWithDefaultGenericArgs<T = Int, U = String>
{
    let t: T;
    let u: U;
};

if (true) {
    let test = new ClassWithDefaultGenericArgs < >;
    Print("ClassWithDefaultGenericArgs < >%\n", test);

    Expect(test.t is Int);
    Expect(test.u is String);
}

if (true) {
    let test = new ClassWithDefaultGenericArgs < Int >;
    Print("ClassWithDefaultGenericArgs < Int >%\n", test);

    Expect(test.t is Int);
    Expect(test.u is String);
}

if (true) {
    let test = new ClassWithDefaultGenericArgs < String, Int >;
    Print("ClassWithDefaultGenericArgs < String, Int >%\n", test);

    Expect(test.t is String);
    Expect(test.u is Int);
}

if (true) {
    let test = new ClassWithDefaultGenericArgs < T : String, U : Int >;
    Print("ClassWithDefaultGenericArgs < T : String, U : Int >%\n", test);

    Expect(test.t is String);
    Expect(test.u is Int);
}

if (true) {
    let test = new ClassWithDefaultGenericArgs < U : String, T : Int >;
    Print("ClassWithDefaultGenericArgs < U : String, T : Int >%\n", test);

    Expect(test.t is Int);
    Expect(test.u is String);
}

func GenericFunction <T> (t : T, cond : Bool)
{
    return cond ? t : t - 1;
}

func GenericFunctionWithDefault <T = Int> (t : T, cond : Bool)
{
    return cond ? t : t + 1;
}

class GenericClass<T>
{
    func DoThing(self, t : T, y : T) : T
    {
        return t + y;
    }
}

if (true) {
    let test = new GenericClass<Int>();
    Expect(test.DoThing(1, 1) is Int);
    Expect(test.DoThing(1, 1) == 2);
}

if (true) {
    let test = new GenericClass<Float>();
    Expect(test.DoThing(1.0, 1.0) is Float);
    Expect(test.DoThing(1.0, 1.0) == 2.0);
}

if (true) {
    let test = new GenericClass<Float>();
    // Expect(test.DoOtherThing<String>(1.0, "hello") is String);
    // Expect(test.DoOtherThing<String>(1.0, "hello") == "hello");
}

if (true) {
    Expect(GenericFunction<Float>(5.0, true) == 5.0);
    Expect(GenericFunction<Float>(5.0, false) == 4.0);
    Expect(GenericFunction<UInt>(5, true) == 5);
    Expect(GenericFunction<UInt>(5, false) == 4);
    Expect(GenericFunction<Int>(5, true) == 5);
    Expect(GenericFunction<Int>(5, false) == 4);

    const u : UInt = 5;
    Expect(u is UInt);

    Expect(GenericFunctionWithDefault<>(5, true) == 5);
    Expect(GenericFunctionWithDefault<>(5, false) == 6);
    Expect(GenericFunctionWithDefault<>(u, true) == 5);
    Expect(GenericFunctionWithDefault<>(u, false) == 6);
    Expect(GenericFunctionWithDefault<>(u, true) == u);
    Expect(GenericFunctionWithDefault<>(u, false) == u + 1);

    // $meta {
    //     // expect to break
    //     func BreakMe <T> ()
    //     {
    //         return 1;
    //     }

    //     BreakMe();
    // }
}

// if (true) {
//     let test = new GenericClass<String>();
//     Expect(test.DoThing("hello ", "world") is String);
//     Expect(test.DoThing("hello ", "world") == "hello world");
// }

export func OnAdded(node: any) {
    //Print("Added controller to node: %s\n", node);

    controller_node = node;

    //Print("controller_node now = %\n", controller_node);

    //mandelbrot::MandlebrotLine();
};

export func OnRemoved(node: any) {
    Print("Remove controller from node: %s\n", controller_node);
    controller_node = null;
};

export func OnTick(node: any, delta: Float) {
    return;

    global_time += delta;
    num_ticks += 1;

    //test_vector.SetX(test_vector.GetX() + delta);

    if (global_time >= 1.0) {
        let avg_time: Float = global_time / num_ticks;

        Print("CPU Ticks per second (in script): %\n", 1.0 / avg_time);
        //Print("test_vector: %\n", test_vector.ToString());
        global_time = 0.0;
        num_ticks = 0;
    }
};